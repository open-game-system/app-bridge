name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: ["**"]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: 18
    
    - name: Setup pnpm
      uses: pnpm/action-setup@v2
      with:
        version: 8
    
    - name: Get pnpm store directory
      id: pnpm-cache
      shell: bash
      run: |
        echo "STORE_PATH=$(pnpm store path)" >> $GITHUB_OUTPUT
    
    - uses: actions/cache@v3
      name: Setup pnpm cache
      with:
        path: ${{ steps.pnpm-cache.outputs.STORE_PATH }}
        key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
        restore-keys: |
          ${{ runner.os }}-pnpm-store-
    
    - name: Install dependencies
      run: pnpm install
    
    - name: Run tests
      run: pnpm run test
      # This will also run typecheck via the turbo dependency chain 

  publish-dev:
    needs: test
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      packages: write
    strategy:
      matrix:
        package: [types, web, native, react, testing]
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: 18
        registry-url: 'https://npm.pkg.github.com'
        scope: '@open-game-system'

    - name: Setup pnpm
      uses: pnpm/action-setup@v3
      with:
        version: 8

    - name: Get pnpm store directory
      id: pnpm-cache
      shell: bash
      run: |
        echo "STORE_PATH=$(pnpm store path)" >> $GITHUB_OUTPUT

    - uses: actions/cache@v4
      name: Setup pnpm cache
      with:
        path: ${{ steps.pnpm-cache.outputs.STORE_PATH }}
        key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
        restore-keys: |
          ${{ runner.os }}-pnpm-store-

    - name: Install dependencies for ${{ matrix.package }}
      run: |
        # Need to install root deps for build tools, and target package deps
        pnpm install --filter @open-game-system/app-bridge-${{ matrix.package }}...

    - name: Build package ${{ matrix.package }}
      run: |
        pnpm turbo run build --filter=@open-game-system/app-bridge-${{ matrix.package }}...

    - name: Generate dev version for ${{ matrix.package }}
      id: version
      run: |
        PACKAGE_DIR="packages/app-bridge-${{ matrix.package }}"
        PACKAGE_JSON_PATH="${PACKAGE_DIR}/package.json"
        
        # Package name from package.json
        PACKAGE_NAME=$(node -p "require('./${PACKAGE_JSON_PATH}').name")
        
        # Extract major version 
        MAJOR_VERSION=$(node -p "require('./${PACKAGE_JSON_PATH}').version.split('.')[0]")
        
        # Generate date
        DATE=$(date +'%Y%m%d')
        
        # Get PR number
        PR_NUMBER=$(echo $GITHUB_REF | sed -n 's/refs\\/pull\\/\\([0-9]*\\)\\/merge/\\1/p')
        
        # Get run attempt for uniqueness within the same PR/run number
        RUN_ATTEMPT=${{ github.run_attempt }}
        
        # Create a version: MAJOR.DATE.0-prN.BUILD_ATTEMPT
        DEV_VERSION="${MAJOR_VERSION}.${DATE}.0-pr${PR_NUMBER}.${RUN_ATTEMPT}"
        
        echo "Generated dev version: ${PACKAGE_NAME}@${DEV_VERSION}"
        echo "DEV_VERSION=${DEV_VERSION}" >> $GITHUB_OUTPUT
        echo "PACKAGE_DIR=${PACKAGE_DIR}" >> $GITHUB_OUTPUT
        echo "PACKAGE_NAME=${PACKAGE_NAME}" >> $GITHUB_OUTPUT
      env:
        GITHUB_REF: ${{ github.ref }}

    - name: Update version in package.json for ${{ matrix.package }}
      run: |
        cd ${{ steps.version.outputs.PACKAGE_DIR }}
        npm version ${{ steps.version.outputs.DEV_VERSION }} --no-git-tag-version --allow-same-version
        
        # Add GitHub registry config
        node -e "
          const fs = require('fs');
          const pkgPath = './package.json';
          const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));
          if (!pkg.publishConfig) pkg.publishConfig = {};
          pkg.publishConfig.registry = 'https://npm.pkg.github.com/';
          pkg.publishConfig.access = 'public'; // Ensure access is set if needed
          fs.writeFileSync(pkgPath, JSON.stringify(pkg, null, 2) + '\\n');
        "

    - name: Copy README, LICENSE, and docs to ${{ matrix.package }}
      run: |
        PACKAGE_DIR=${{ steps.version.outputs.PACKAGE_DIR }}
        cp README.md $PACKAGE_DIR/
        cp LICENSE $PACKAGE_DIR/ 2>/dev/null || :
        # Copy docs folder if it exists in root
        if [ -d "docs" ]; then
          mkdir -p $PACKAGE_DIR/docs
          cp -R docs/* $PACKAGE_DIR/docs/ 2>/dev/null || :
        fi
        # Copy package-specific README if different from root
        if [ -f "$PACKAGE_DIR/README.md" ] && ! cmp -s README.md $PACKAGE_DIR/README.md; then
           echo "Using package-specific README for $PACKAGE_DIR"
        else
           cp README.md $PACKAGE_DIR/
        fi


    - name: Publish ${{ matrix.package }} to GitHub Packages
      env:
        NODE_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        cd ${{ steps.version.outputs.PACKAGE_DIR }}
        npm publish --tag dev

    - name: Comment on PR for ${{ matrix.package }}
      uses: actions/github-script@v7
      if: success() # Only comment if publish succeeded
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const prNumber = context.issue.number;
          const version = '${{ steps.version.outputs.DEV_VERSION }}';
          const packageName = '${{ steps.version.outputs.PACKAGE_NAME }}';
          const repoName = context.repo.owner + '/' + context.repo.repo;
          
          github.rest.issues.createComment({
            issue_number: prNumber,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: `ðŸ“¦ Dev version published for \`${packageName}\`: \`${packageName}@${version}\`\n\nInstall via GitHub Packages (ensure .npmrc is configured):\n\`\`\`bash\npnpm add ${packageName}@${version}\n\`\`\``
          });

  publish-production:
    needs: test
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    permissions:
      contents: write  # Needed to push version commit
      packages: write # Needed to publish to npm
    strategy:
      matrix:
        package: [types, web, native, react, testing]
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }} # Use GITHUB_TOKEN for checkout to allow push later

    - name: Setup Git User
      run: |
        git config --global user.name 'github-actions[bot]'
        git config --global user.email 'github-actions[bot]@users.noreply.github.com'

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: 18
        registry-url: 'https://registry.npmjs.org' # Target npm registry

    - name: Setup pnpm
      uses: pnpm/action-setup@v3
      with:
        version: 8
        
    - name: Get pnpm store directory
      id: pnpm-cache
      shell: bash
      run: |
        echo "STORE_PATH=$(pnpm store path)" >> $GITHUB_OUTPUT

    - uses: actions/cache@v4
      name: Setup pnpm cache
      with:
        path: ${{ steps.pnpm-cache.outputs.STORE_PATH }}
        key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
        restore-keys: |
          ${{ runner.os }}-pnpm-store-

    - name: Install dependencies for ${{ matrix.package }}
      run: |
        # Need to install root deps for build tools, and target package deps
        pnpm install --filter @open-game-system/app-bridge-${{ matrix.package }}...

    - name: Build package ${{ matrix.package }}
      run: |
        pnpm turbo run build --filter=@open-game-system/app-bridge-${{ matrix.package }}...
        
    - name: Generate production version for ${{ matrix.package }}
      id: version
      run: |
        PACKAGE_DIR="packages/app-bridge-${{ matrix.package }}"
        PACKAGE_JSON_PATH="${PACKAGE_DIR}/package.json"
        PACKAGE_NAME=$(node -p "require('./${PACKAGE_JSON_PATH}').name")
        MAJOR_VERSION=$(node -p "require('./${PACKAGE_JSON_PATH}').version.split('.')[0]")
        DATE=$(date +'%Y%m%d')
        
        echo "Checking npm for existing versions of ${PACKAGE_NAME} with prefix ${MAJOR_VERSION}.${DATE}..."
        
        # Get published versions, handle errors/empty results
        NPM_VERSIONS=$(npm view ${PACKAGE_NAME} versions --json 2>/dev/null || echo "[]")
        
        # Find highest patch for today
        HIGHEST_PATCH=-1
        if [[ "$NPM_VERSIONS" != "[]" && "$NPM_VERSIONS" != *error* ]]; then
          PATTERN="${MAJOR_VERSION}.${DATE}."
          HIGHEST_PATCH=$(echo "$NPM_VERSIONS" | jq -c --arg pattern "$PATTERN" 'map(select(startswith($pattern))) | map(split(".")[2] | tonumber) | max // -1')
        fi
        
        # Calculate next patch version
        NEXT_PATCH=$((HIGHEST_PATCH + 1))
        NEW_VERSION="${MAJOR_VERSION}.${DATE}.${NEXT_PATCH}"
        
        echo "Generated production version: ${PACKAGE_NAME}@${NEW_VERSION}"
        echo "NEW_VERSION=${NEW_VERSION}" >> $GITHUB_OUTPUT
        echo "PACKAGE_DIR=${PACKAGE_DIR}" >> $GITHUB_OUTPUT
        echo "PACKAGE_NAME=${PACKAGE_NAME}" >> $GITHUB_OUTPUT

    - name: Update version in package.json for ${{ matrix.package }}
      run: |
        cd ${{ steps.version.outputs.PACKAGE_DIR }}
        # Use --allow-same-version in case patch calculation resulted in 0 and current version is also 0
        npm version ${{ steps.version.outputs.NEW_VERSION }} --no-git-tag-version --allow-same-version 
        
        # Ensure public access in package.json for npm
        node -e "
          const fs = require('fs');
          const pkgPath = './package.json';
          const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));
          if (!pkg.publishConfig) pkg.publishConfig = {};
          pkg.publishConfig.access = 'public';
          // Remove GH registry if present from dev builds
          delete pkg.publishConfig.registry; 
          fs.writeFileSync(pkgPath, JSON.stringify(pkg, null, 2) + '\\n');
        "

    - name: Copy README, LICENSE, and docs to ${{ matrix.package }}
      run: |
        PACKAGE_DIR=${{ steps.version.outputs.PACKAGE_DIR }}
        # Use package-specific README if it exists, otherwise use root
        if [ -f "$PACKAGE_DIR/README.md" ]; then
           echo "Using package-specific README for $PACKAGE_DIR"
        else
           cp README.md $PACKAGE_DIR/
        fi
        cp LICENSE $PACKAGE_DIR/ 2>/dev/null || :
        if [ -d "docs" ]; then
          mkdir -p $PACKAGE_DIR/docs
          cp -R docs/* $PACKAGE_DIR/docs/ 2>/dev/null || :
        fi

    - name: Publish ${{ matrix.package }} to npm
      env:
        NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
      run: |
        cd ${{ steps.version.outputs.PACKAGE_DIR }}
        npm publish --access public

    - name: Commit and Push version bump for ${{ matrix.package }}
      run: |
        PACKAGE_DIR=${{ steps.version.outputs.PACKAGE_DIR }}
        PACKAGE_NAME=${{ steps.version.outputs.PACKAGE_NAME }}
        NEW_VERSION=${{ steps.version.outputs.NEW_VERSION }}
        
        # Check if the package.json was actually changed by npm version
        if git status --porcelain | grep -q "${PACKAGE_DIR}/package.json"; then
          git add "${PACKAGE_DIR}/package.json"
          git commit -m "ci: Bump ${PACKAGE_NAME} to ${NEW_VERSION} [skip ci]"
          # Add retry logic for push in case of conflicts from parallel jobs
          n=0
          until [ $n -ge 5 ]
          do
             git pull --rebase && git push && break # Pull first to minimize conflicts, then push
             n=$((n+1))
             sleep 15 # Wait before retrying
          done
          if [ $n -ge 5 ]; then
             echo "Failed to push version bump for ${PACKAGE_NAME} after multiple retries."
             exit 1
          fi
        else
          echo "No version change detected for ${PACKAGE_NAME}. Skipping commit."
        fi 